# -*- coding: utf-8 -*-
"""SOLEMNE-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LavK5GdUl7s8zV28DZhLGHvTFVYMUdBj
"""

import requests
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt

# Función para obtener datos desde la API
@st.cache
def fetch_country_data():
    url = "https://restcountries.com/v3.1/all"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    else:
        st.error("No se pudieron obtener los datos. Intente más tarde.")
        return []

# Función para procesar datos
@st.cache
def process_data(data):
    countries = []
    for country in data:
        countries.append({
            "Nombre": country.get("name", {}).get("common", "N/A"),
            "Región": country.get("region", "N/A"),
            "Población": country.get("population", 0),
            "Área (km²)": country.get("area", 0),
            "Fronteras": len(country.get("borders", [])),
            "Idiomas": len(country.get("languages", {}).keys()),
            "Zonas Horarias": len(country.get("timezones", []))
        })
    return pd.DataFrame(countries)

# Inicio de la Aplicación Streamlit
st.title("Análisis de Datos de Países con REST Countries API")
st.sidebar.title("Navegación")
menu = st.sidebar.radio("Selecciona una página", ["Inicio", "Interacción con Datos", "Gráficos"])

data = fetch_country_data()
dataframe = process_data(data)

if menu == "Inicio":
    st.header("Descripción del Proyecto")
    st.write("""
    Esta aplicación interactiva utiliza datos de la API REST Countries para analizar información
    sobre países, incluyendo su población, área, idiomas oficiales, regiones, y más.
    """)
    st.write("[Visita la API REST Countries](https://restcountries.com/v3.1/all)")
    st.dataframe(dataframe)

elif menu == "Interacción con Datos":
    st.header("Interacción con Datos")

    st.subheader("Estadísticas de una Columna")
    column = st.selectbox("Selecciona una columna:", dataframe.select_dtypes(include=['float64', 'int64']).columns)
    if column:
        st.write(f"Media: {dataframe[column].mean()}")
        st.write(f"Mediana: {dataframe[column].median()}")
        st.write(f"Desviación estándar: {dataframe[column].std()}")

    st.subheader("Ordenar Datos")
    column_sort = st.selectbox("Selecciona una columna para ordenar:", dataframe.columns)
    order = st.radio("Ordenar:", ["Ascendente", "Descendente"])
    if column_sort:
        sorted_df = dataframe.sort_values(by=column_sort, ascending=(order == "Ascendente"))
        st.dataframe(sorted_df)

    st.subheader("Filtrar Datos")
    column_filter = st.selectbox("Selecciona una columna numérica para filtrar:", dataframe.select_dtypes(include=['float64', 'int64']).columns)
    if column_filter:
        min_val, max_val = st.slider("Selecciona el rango:", float(dataframe[column_filter].min()), float(dataframe[column_filter].max()), (float(dataframe[column_filter].min()), float(dataframe[column_filter].max())))
        filtered_df = dataframe[(dataframe[column_filter] >= min_val) & (dataframe[column_filter] <= max_val)]
        st.dataframe(filtered_df)

    if st.button("Descargar Datos Filtrados"):
        filtered_df.to_csv("datos_filtrados.csv", index=False)
        st.success("Archivo descargado: datos_filtrados.csv")

elif menu == "Gráficos":
    st.header("Gráficos Interactivos")

    x_axis = st.selectbox("Selecciona el eje X:", dataframe.select_dtypes(include=['float64', 'int64']).columns)
    y_axis = st.selectbox("Selecciona el eje Y:", dataframe.select_dtypes(include=['float64', 'int64']).columns)

    chart_type = st.radio("Selecciona el tipo de gráfico:", ["Dispersión", "Línea", "Barras"])

    if chart_type and x_axis and y_axis:
        fig, ax = plt.subplots()
        if chart_type == "Dispersión":
            ax.scatter(dataframe[x_axis], dataframe[y_axis])
        elif chart_type == "Línea":
            ax.plot(dataframe[x_axis], dataframe[y_axis])
        elif chart_type == "Barras":
            ax.bar(dataframe[x_axis], dataframe[y_axis])

        ax.set_xlabel(x_axis)
        ax.set_ylabel(y_axis)
        ax.set_title(f"{chart_type} de {x_axis} vs {y_axis}")
        st.pyplot(fig)

    if st.button("Descargar Gráfico"):
        fig.savefig("grafico.png")
        st.success("Archivo descargado: grafico.png")