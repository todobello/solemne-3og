# -*- coding: utf-8 -*-
"""SOLEMNE-3.ipynb

Automatically generated by Colab.

Original file is located at
    https://colab.research.google.com/drive/1LavK5GdUl7s8zV28DZhLGHvTFVYMUdBj
"""

import requests
import pandas as pd
import streamlit as st
import matplotlib.pyplot as plt

# Obtener datos de la API REST Countries
@st.cache
def fetch_data():
    url = "https://restcountries.com/v3.1/all"
    response = requests.get(url)
    if response.status_code == 200:
        return response.json()
    else:
        st.error("No se pudieron obtener los datos de la API.")
        return []

data = fetch_data()

# Procesar datos
if data:
    countries = []
    for country in data:
        countries.append({
            "Nombre": country.get("name", {}).get("common", "N/A"),
            "Región": country.get("region", "N/A"),
            "Población": country.get("population", 0),
            "Área": country.get("area", 0),
            "Fronteras": len(country.get("borders", [])),
            "Idiomas": len(country.get("languages", {})),
            "Zonas Horarias": len(country.get("timezones", []))
        })

    df = pd.DataFrame(countries)

    # Configurar multipágina
    st.set_page_config(page_title="Solemne 3 - API REST Countries", layout="wide")

    # Página 1: Descripción del proyecto
    def descripcion():
        st.title("Solemne 3: Visualización de Datos con Streamlit")
        st.markdown(
            """
            ### Proyecto basado en la API REST Countries
            Este proyecto utiliza datos obtenidos de [REST Countries API](https://restcountries.com/v3.1/all) 
            para explorar y analizar información sobre países del mundo. La aplicación incluye:
            - Estadísticas básicas y filtros.
            - Visualización de datos interactiva.
            - Descarga de gráficos y datos procesados.
            """
        )

    # Página 2: Interacción con los datos
    def interaccion():
        st.title("Interacción con los Datos")
        st.dataframe(df)

        # Estadísticas básicas
        columna = st.selectbox("Selecciona una columna para estadísticas básicas", df.select_dtypes(include=[int, float]).columns)
        if columna:
            st.write(f"Media de {columna}: {df[columna].mean():.2f}")
            st.write(f"Mediana de {columna}: {df[columna].median():.2f}")
            st.write(f"Desviación estándar de {columna}: {df[columna].std():.2f}")

        # Ordenar datos
        columna_orden = st.selectbox("Selecciona una columna para ordenar", df.columns)
        orden_ascendente = st.radio("Ordenar en forma ascendente?", ("Sí", "No")) == "Sí"
        df_ordenado = df.sort_values(by=columna_orden, ascending=orden_ascendente)
        st.dataframe(df_ordenado)

        # Filtrar filas
        columna_filtro = st.selectbox("Selecciona una columna numérica para filtrar", df.select_dtypes(include=[int, float]).columns)
        if columna_filtro:
            rango = st.slider("Selecciona el rango de valores", float(df[columna_filtro].min()), float(df[columna_filtro].max()), (float(df[columna_filtro].min()), float(df[columna_filtro].max())))
            df_filtrado = df[(df[columna_filtro] >= rango[0]) & (df[columna_filtro] <= rango[1])]
            st.dataframe(df_filtrado)

            # Descargar datos filtrados
            st.download_button(
                "Descargar datos filtrados en CSV",
                data=df_filtrado.to_csv(index=False),
                file_name="datos_filtrados.csv",
                mime="text/csv"
            )

    # Página 3: Gráficos interactivos
    def graficos():
        st.title("Gráficos Interactivos")

        # Selección de variables
        x_col = st.selectbox("Selecciona la variable para el eje X", df.select_dtypes(include=[int, float]).columns)
        y_col = st.selectbox("Selecciona la variable para el eje Y", df.select_dtypes(include=[int, float]).columns)

        # Rango personalizado
        if x_col and y_col:
            x_min, x_max = st.slider("Rango del eje X", float(df[x_col].min()), float(df[x_col].max()), (float(df[x_col].min()), float(df[x_col].max())))
            y_min, y_max = st.slider("Rango del eje Y", float(df[y_col].min()), float(df[y_col].max()), (float(df[y_col].min()), float(df[y_col].max())))

            # Tipo de gráfico
            tipo_grafico = st.selectbox("Selecciona el tipo de gráfico", ["Dispersión", "Línea", "Barra"])

            # Generar gráfico
            fig, ax = plt.subplots()
            if tipo_grafico == "Dispersión":
                ax.scatter(df[x_col], df[y_col])
            elif tipo_grafico == "Línea":
                ax.plot(df[x_col], df[y_col])
            elif tipo_grafico == "Barra":
                ax.bar(df[x_col], df[y_col])

            ax.set_xlim(x_min, x_max)
            ax.set_ylim(y_min, y_max)
            ax.set_xlabel(x_col)
            ax.set_ylabel(y_col)
            ax.set_title(f"Gráfico de {tipo_grafico}")
            st.pyplot(fig)

            # Descargar gráfico
            st.download_button(
                "Descargar gráfico en PNG",
                data=fig_to_png(fig),
                file_name="grafico.png",
                mime="image/png"
            )

    # Conversión de gráfico a PNG
    def fig_to_png(fig):
        import io
        buf = io.BytesIO()
        fig.savefig(buf, format="png")
        buf.seek(0)
        return buf.getvalue()

    # Navegación entre páginas
    page = st.sidebar.selectbox("Navega entre las páginas", ["Descripción", "Interacción", "Gráficos"])

    if page == "Descripción":
        descripcion()
    elif page == "Interacción":
        interaccion()
    elif page == "Gráficos":
        graficos()
